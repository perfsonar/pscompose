<div class="datatype new-form" hx-ext="dynamic-url">
    <div class="page">
        <div class="header">
            <h2 id="data-name"></h2>
            <input-checkbox-star></input-checkbox-star>
        </div>
        <div class="content">
            <form id="data-form">
                <fieldset id="content" hx-trigger="load" nunjucks-template="example-template">
                    <i class="spinner" data-lucide="loader-circle"></i>
                </fieldset>

                <script id="example-template" type="nunjucks">
                    <json-form
                      form-data='{{ form_data | dump }}'
                      schema-data='{{ json_schema | dump }}'
                      layout-data='{{ ui_schema | dump }}'
                    ></json-form>
                </script>

                <div class="save-cancel">
                    <web-button
                        type="submit"
                        data-label="Save"
                        data-theme="Secondary"
                        data-righticon="save"
                        confirm-modal="save-modal"
                    >
                    </web-button>
                    <div hx-get="/partials/confirm-modals.html" hx-trigger="load"></div>
                </div>
            </form>
        </div>
    </div>
</div>

<script>
    var params = new URLSearchParams(window.location.search);
    var id = params.get("id");
    var datatype = psCompose.activeRoute.singular.toLowerCase();

    var selectedType = null;
    var additionalSchema = null;

    // Setting the hx-get attribute dynamically
    document
        .getElementById("content")
        .setAttribute("hx-get", `${psCompose.activeRoute.list_endpoint}new/form`);

    // Set Up JSON Form
    document.body.addEventListener("json-form:mounted", () => {
        document.getElementById("data-name").textContent = "New " + psCompose.activeRoute.singular;
    });

    // Save
    document.getElementById("data-form").addEventListener("submit", async function (event) {
        event.preventDefault();

        if (!document.querySelector("json-form").validate()) {
            sessionStorage.setItem(
                "confirmMessage",
                JSON.stringify(["Form fields not all valid", "Error"]),
            );
            processLastMessage();
        } else {
            document.querySelector("json-form").dispatchEvent(new Event("validated"));
            document
                .querySelector("#save-modal")
                .addEventListener("confirm-yes-clicked", async function (event) {
                    // 1. Retrieve jsonform data
                    const elem = document.querySelector("json-form");
                    const form_data = JSON.parse(elem.serializeForm());
                    const { name, ...rest } = form_data; // Need to remove name from the form

                    // TODO: Do we need to set "url" to something here? Is url going to always remain the same?
                    const data = {
                        ref_set: [],
                        type: datatype,
                        json: rest,
                        name: name,
                        created_by: "ssbaveja", // TODO: this will not be needed since it'll be parsed from user object
                        last_edited_by: "ssbaveja", // TODO: this will not be needed since it'll be parsed from user object
                        // url: ""
                    };

                    console.log("Submitting data ", data);

                    // 1.1 Additional properties added according to datatype
                    if (datatype == "group") {
                        data.schema = JSON.parse(elem.schemaData);
                        data.group_type = rest.type;
                    }

                    // 2. Post request to api
                    try {
                        const response = await fetch(`${psCompose.activeRoute.list_endpoint}`, {
                            method: "POST",
                            headers: { "Content-Type": "application/json" },
                            body: JSON.stringify(data),
                        });

                        if (!response.ok) throw new Error(`HTTP error ${response.statusText}`);
                        const result = await response.json();
                        savemsg = psCompose.activeRoute.singular + " saved successfully!";
                        sessionStorage.setItem(
                            "confirmMessage",
                            JSON.stringify([savemsg, "Success"]),
                        );

                        // 3. Redirect
                        window.location = psCompose.activeRoute.page_url + "?id=" + result.id;
                    } catch (error) {
                        console.error("Error:", error);
                        sessionStorage.setItem(
                            "confirmMessage",
                            JSON.stringify(["Something went wrong.", "Error"]),
                        );
                        processLastMessage();
                    }
                });
        }
    });

    document.getElementById("data-form").addEventListener("change", async function (event) {
        console.log(
            "Change event detected:",
            event.target.name,
            event.target.label,
            event.target.value,
        );

        // Dynamically update schema for certain types
        if (psCompose.activeMenuItem === "tests") {
            const elem = document.querySelector("json-form");

            // --- Handle test type change ---
            if (event.target.label === "Type") {
                selectedType = event.target.value;
                additionalSchema = await getAdditionalSchema(selectedType);
                handleTypeChange(selectedType, additionalSchema);
            }

            // --- Fetch from FastAPI backend ---
            async function getAdditionalSchema(type) {
                try {
                    const url = `${psCompose.activeRoute.list_endpoint}new/${type}/form`;
                    const res = await fetch(url, {
                        method: "GET",
                        headers: { "Content-Type": "application/json" },
                    });
                    if (!res.ok) throw new Error(`Failed to fetch schema: ${res.status}`);
                    const data = await res.json();
                    return data;
                } catch (err) {
                    console.error("Error fetching schema:", err);
                }
            }

            // --- Handle version change ---
            if (event.target.label === "Version") {
                const newVersion = JSON.parse(event.target.value);
                updateIdleVersion(newVersion, additionalSchema);
            }

            function findGroup(layout) {
                return layout.elements.find(
                    (el) =>
                        el.type === "Group" && el.rule?.condition?.scope === "#/properties/type",
                );
            }

            function mergeSchema(baseSchema, versionData) {
                Object.assign(baseSchema.properties, versionData.properties);
                baseSchema.required = [
                    ...new Set([...(baseSchema.required || []), ...(versionData.required || [])]),
                ];
            }

            function mergeLayout(group, uiVersionData) {
                // Keep version dropdown, replace the rest
                group.elements = group.elements.slice(0, 1).concat(uiVersionData.elements);
            }

            function ensureVersionDropdown(group) {
                group.elements = Array.isArray(group.elements) ? group.elements : [];
                if (!group.elements.some((e) => e.scope === "#/properties/version")) {
                    group.elements.unshift({
                        type: "Control",
                        scope: "#/properties/version",
                        customComponent: "dropdown-single-select",
                    });
                }
            }

            function handleTypeChange(selectedType, additionalSchema) {
                console.log("Selected type ", selectedType, additionalSchema);

                const versions = (additionalSchema?.spec?.versions || []).filter((v) => v !== null);
                if (!versions.length) return;

                const highestVersion = versions.sort((a, b) => Number(b) - Number(a))[0];
                console.log("Highest version:", highestVersion);

                const baseSchema = JSON.parse(elem.schemaData);
                const baseLayout = JSON.parse(elem.layoutData);

                const group = findGroup(baseLayout);
                if (!group) return;

                // Show condition and add dropdown
                group.rule.condition.schema.const = selectedType;
                ensureVersionDropdown(group);

                // --- Add Version field to JSON and UI schema to show list of versions ---
                if (!baseSchema.properties.version) {
                    baseSchema.properties.version = {
                        type: "string",
                        title: "Version",
                        oneOf: versions.map((v) => ({
                            const: v,
                            title: `Version ${v}`,
                        })),
                        default: highestVersion,
                    };
                }

                // Load schema and UI schema for highest version
                const versionData = additionalSchema.spec.jsonschema.versions[highestVersion];
                const uiVersionData = additionalSchema.spec.uischema.versions[highestVersion];

                mergeSchema(baseSchema, versionData);
                mergeLayout(group, uiVersionData);

                // --- APPLY TO FORM ---
                elem.setAttribute("schema-data", JSON.stringify(baseSchema));
                elem.setAttribute("layout-data", JSON.stringify(baseLayout));

                console.log("Idle Schema:", baseSchema);
                console.log("Idle UI Schema:", baseLayout);
            }

            function updateIdleVersion(selectedVersion, additionalSchema) {
                console.log("Updating to Idle version:", selectedVersion, additionalSchema);
                const elem = document.querySelector("json-form");
                const currentSchema = JSON.parse(elem.schemaData);
                const currentLayout = JSON.parse(elem.layoutData);

                const versionData = additionalSchema.spec.jsonschema.versions[selectedVersion];
                const uiVersionData = additionalSchema.spec.uischema.versions[selectedVersion];

                if (!versionData || !uiVersionData) return;

                mergeSchema(currentSchema, versionData);

                const group = findGroup(currentLayout);
                if (!group) return;

                mergeLayout(group, uiVersionData);

                elem.setAttribute("schema-data", JSON.stringify(currentSchema));
                elem.setAttribute("layout-data", JSON.stringify(currentLayout));

                console.log("New Idle Schema:", currentSchema);
                console.log("New Idle UI Schema:", currentLayout);
            }
        }
    });
</script>
