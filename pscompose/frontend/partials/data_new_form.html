<div class="datatype new-form" hx-ext="dynamic-url">
    <div class="page">
        <div class="header">
            <h2 id="data-name"></h2>
            <input-checkbox-star></input-checkbox-star>
        </div>
        <div class="content">
            <form id="data-form">
                <fieldset id="content" hx-trigger="load" nunjucks-template="example-template">
                    <i class="spinner" data-lucide="loader-circle"></i>
                </fieldset>

                <script id="example-template" type="nunjucks">
                    <json-form
                      form-data='{{ form_data | dump }}'
                      schema-data='{{ json_schema | dump }}'
                      layout-data='{{ ui_schema | dump }}'
                    ></json-form>
                </script>

                <div class="save-cancel">
                    <web-button
                        type="submit"
                        label="Save"
                        theme="Secondary"
                        righticon="save"
                        confirm-modal="save-modal"
                    >
                    </web-button>
                </div>
            </form>
        </div>
    </div>
</div>

<script>
    var params = new URLSearchParams(window.location.search);
    var id = params.get("id");
    var datatype = psCompose.activeRoute.singular.toLowerCase();

    var selectedType = null;
    var additionalSchema = null;

    // Setting the hx-get attribute dynamically
    document
        .getElementById("content")
        .setAttribute("hx-get", `${psCompose.activeRoute.list_endpoint}/new/form`);

    // Set Up JSON Form
    document.body.addEventListener("json-form:mounted", () => {
        document.getElementById("data-name").textContent = "New " + psCompose.activeRoute.singular;
    });

    // Save
    document.getElementById("data-form").addEventListener("submit", async function (event) {
        event.preventDefault();

        const elem = document.querySelector("json-form");
        const form_data = JSON.parse(elem.serializeForm());
        const group_with_excludes = Boolean(datatype == "group" && !!form_data["excludes"]);

        // don't validate if there is excludes
        if (!document.querySelector("json-form").validate() && !group_with_excludes) {
            sessionStorage.setItem(
                "confirmMessage",
                JSON.stringify(["Form fields not all valid", "Error"]),
            );
            processLastMessage();
        } else {
            document.querySelector("json-form").dispatchEvent(new Event("validated"));
            document
                .querySelector("#save-modal")
                .addEventListener("confirm-yes-clicked", async function (event) {
                    // 1. Retrieve jsonform data
                    const { name, ...rest } = form_data; // Need to remove name from the form

                    // TODO: Do we need to set "url" to something here? Is url going to always remain the same?
                    const data = {
                        ref_set: [],
                        type: datatype,
                        json: rest,
                        name: name,
                        created_by: "ssbaveja", // TODO: this will not be needed since it'll be parsed from user object
                        last_edited_by: "ssbaveja", // TODO: this will not be needed since it'll be parsed from user object
                        // url: ""
                    };

                    console.log("Submitting data ", data);

                    // 1.1 Additional properties added according to datatype
                    if (datatype == "group") {
                        data.schema = JSON.parse(elem.schemaData);
                        data.group_type = rest.type;
                    }

                    // 2. Post request to api
                    try {
                        const response = await fetch(`${psCompose.activeRoute.list_endpoint}/`, {
                            method: "POST",
                            headers: { "Content-Type": "application/json" },
                            body: JSON.stringify(data),
                        });

                        if (!response.ok) throw new Error(`HTTP error ${response.statusText}`);
                        const result = await response.json();
                        savemsg = psCompose.activeRoute.singular + " saved successfully!";
                        sessionStorage.setItem(
                            "confirmMessage",
                            JSON.stringify([savemsg, "Success"]),
                        );

                        // 3. Redirect
                        window.location = psCompose.activeRoute.page_url + "?id=" + result.id;
                    } catch (error) {
                        console.error("Error:", error);
                        sessionStorage.setItem(
                            "confirmMessage",
                            JSON.stringify(["Something went wrong.", "Error"]),
                        );
                        processLastMessage();
                    }
                });
        }
    });

    document.getElementById("data-form").addEventListener("change", async function (event) {
        console.log(
            "Change event detected:",
            event.target.name,
            event.target.label,
            event.target.value,
        );

        // Dynamically update schema for certain types
        if (psCompose.activeMenuItem === "tests") {
            const elem = document.querySelector("json-form");

            // --- Handle test type change ---
            if (event.target.label === "Type") {
                selectedType = event.target.value;
                additionalSchema = await getAdditionalSchema(selectedType);
                handleTypeChange(selectedType, additionalSchema);
            }

            // --- Fetch from FastAPI backend ---
            async function getAdditionalSchema(type) {
                try {
                    const url = `${psCompose.activeRoute.list_endpoint}/new/${type}/form`;
                    const res = await fetch(url, {
                        method: "GET",
                        headers: { "Content-Type": "application/json" },
                    });
                    if (!res.ok) throw new Error(`Failed to fetch schema: ${res.status}`);
                    const data = await res.json();
                    return data;
                } catch (err) {
                    console.error("Error fetching schema:", err);
                }
            }

            // --- Handle version change ---
            if (event.target.label === "Version") {
                const newVersion = JSON.parse(event.target.value);
                updateIdleVersion(newVersion, additionalSchema);
            }

            function findGroup(layout) {
                return layout.elements.find(
                    (el) =>
                        el.type === "Group" && el.rule?.condition?.scope === "#/properties/type",
                );
            }

            function mergeSchema(baseSchema, versionData) {
                // Remove old version-specific properties but keep name, type, _meta, and version
                const keysToKeep = ["name", "type", "_meta", "version"];
                const keysToRemove = Object.keys(baseSchema.properties).filter(
                    (key) => !keysToKeep.includes(key),
                );
                keysToRemove.forEach((key) => delete baseSchema.properties[key]);

                // Add new version's properties
                Object.assign(baseSchema.properties, versionData.properties);

                // Set required fields - keep base required fields plus new version's required
                const baseRequired = ["name", "type"];
                baseSchema.required = [
                    ...new Set([...baseRequired, ...(versionData.required || [])]),
                ];
            }

            function mergeLayout(group, uiVersionData) {
                // Keep version dropdown, replace the rest
                group.elements = group.elements.slice(0, 1).concat(uiVersionData.elements);
            }

            function ensureVersionDropdown(group) {
                group.elements = Array.isArray(group.elements) ? group.elements : [];
                if (!group.elements.some((e) => e.scope === "#/properties/version")) {
                    group.elements.unshift({
                        type: "Control",
                        scope: "#/properties/version",
                        customComponent: "dropdown-single-select",
                    });
                }
            }

            function handleTypeChange(selectedType, additionalSchema) {
                console.log("Selected type ", selectedType, additionalSchema);

                const versions = (additionalSchema?.spec?.versions || []).filter((v) => v !== null);
                if (!versions.length) return;

                const highestVersion = versions.sort((a, b) => Number(b) - Number(a))[0];
                console.log("Highest version:", highestVersion);

                const baseSchema = JSON.parse(elem.schemaData);
                const baseLayout = JSON.parse(elem.layoutData);

                const group = findGroup(baseLayout);
                if (!group) return;

                // Show condition and add dropdown
                group.rule.condition.schema.const = selectedType;
                ensureVersionDropdown(group);

                // --- Add Version field to JSON and UI schema to show list of versions ---
                console.log("baseSchema.properties.version ", baseSchema.properties.version);
                baseSchema.properties.version = {
                    type: "string",
                    title: "Version",
                    oneOf: versions.map((v) => ({
                        const: v,
                        title: `Version ${v}`,
                    })),
                    default: highestVersion,
                };
                console.log("AFTER baseSchema.properties.version ", baseSchema.properties.version);

                // Load schema and UI schema for highest version
                const versionData = additionalSchema.spec.jsonschema.versions[highestVersion];
                const uiVersionData = additionalSchema.spec.uischema.versions[highestVersion];

                mergeSchema(baseSchema, versionData);
                mergeLayout(group, uiVersionData);

                // Get current form data and initialize with default values
                const currentFormData = JSON.parse(elem.serializeForm());

                // Initialize all version-specific fields with their default values or clear them
                Object.keys(versionData.properties).forEach((key) => {
                    const property = versionData.properties[key];
                    if (property.default !== undefined) {
                        // Set to default value
                        currentFormData[key] = property.default;
                    } else {
                        // No default, clear the field
                        delete currentFormData[key];
                    }
                });

                currentFormData.version = String(highestVersion);
                currentFormData.schema = highestVersion;

                // --- APPLY TO FORM ---
                elem.setAttribute("schema-data", JSON.stringify(baseSchema));
                elem.setAttribute("layout-data", JSON.stringify(baseLayout));
                elem.setAttribute("form-data", JSON.stringify(currentFormData));

                console.log("Schema:", baseSchema);
                console.log("UI Schema:", baseLayout);
                console.log("Form Data:", currentFormData);
            }

            function updateIdleVersion(selectedVersion, additionalSchema) {
                console.log("Updating to version:", selectedVersion, additionalSchema);
                const elem = document.querySelector("json-form");
                const currentSchema = JSON.parse(elem.schemaData);
                const currentLayout = JSON.parse(elem.layoutData);

                // Get current form values from the serialized form, not the initial formData
                const currentFormData = JSON.parse(elem.serializeForm());

                const versionData = additionalSchema.spec.jsonschema.versions[selectedVersion];
                const uiVersionData = additionalSchema.spec.uischema.versions[selectedVersion];

                if (!versionData || !uiVersionData) return;

                mergeSchema(currentSchema, versionData);

                const group = findGroup(currentLayout);
                if (!group) return;

                mergeLayout(group, uiVersionData);

                // Clean up form data - remove fields that are no longer in the new version's schema
                // and reset fields to their new default values (or empty if no default)
                const newSchemaProperties = new Set(Object.keys(versionData.properties));
                newSchemaProperties.add("name"); // Keep base fields
                newSchemaProperties.add("type");
                newSchemaProperties.add("_meta");
                newSchemaProperties.add("version");

                // Remove fields that don't exist in the new version
                Object.keys(currentFormData).forEach((key) => {
                    if (!newSchemaProperties.has(key)) {
                        delete currentFormData[key];
                    }
                });

                // Reset all version-specific fields to their default values or clear them
                Object.keys(versionData.properties).forEach((key) => {
                    const property = versionData.properties[key];
                    if (property.default !== undefined) {
                        // Set to new default value
                        currentFormData[key] = property.default;
                    } else {
                        // No default, clear the field if it exists
                        delete currentFormData[key];
                    }
                });

                // Keep version as string in form data so dropdown can match it
                currentFormData.version = String(selectedVersion);

                elem.setAttribute("schema-data", JSON.stringify(currentSchema));
                elem.setAttribute("layout-data", JSON.stringify(currentLayout));
                elem.setAttribute("form-data", JSON.stringify(currentFormData));

                console.log("New Schema:", currentSchema);
                console.log("New UI Schema:", currentLayout);
                console.log("New Form Data:", currentFormData);
            }
        }
    });
</script>
